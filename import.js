// Generated by CoffeeScript 1.3.3
(function() {
  var async, cached_files, collectDependencies, compile, fs, options, parseFile, parsers, path, resolveDependencyChain, resolvePath, root;

  fs = require('fs');

  path = require('path');

  async = require('async');

  parseFile = function(full_path, cb) {
    var file;
    file = {
      path: full_path,
      compiled_js: null,
      mtime: null,
      deps: []
    };
    return fs.stat(full_path, function(err, stat) {
      if (err) {
        cb(err);
        return;
      }
      file.mtime = +stat.mtime;
      return fs.readFile(full_path, 'utf8', function(err, source) {
        var import_string, parser, re, result;
        if (err) {
          cb(err);
          return;
        }
        parser = parsers[path.extname(full_path)];
        try {
          file.compiled_js = parser.compile(source);
        } catch (err) {
          cb("" + full_path + "\n" + err);
          return;
        }
        re = parser.import_re;
        re.lastIndex = 0;
        while (result = re.exec(source)) {
          import_string = result[1].slice(1, -1);
          if (import_string[0] !== '/') {
            import_string = path.join(path.dirname(full_path), import_string);
          }
          file.deps.push(import_string);
        }
        return cb(null, file);
      });
    });
  };

  resolvePath = function(import_string, doneResolvingPath) {
    var resolveWithExt;
    resolveWithExt = function(ext, cb) {
      return fs.realpath(path.resolve(import_string + ext), function(err, real_path) {
        if (err) {
          cb(null, null);
          return;
        }
        return fs.stat(real_path, function(err, stat) {
          if (err || stat.isDirectory()) {
            return cb(null, null);
          } else {
            return cb(null, real_path);
          }
        });
      });
    };
    return async.map([""].concat(Object.keys(parsers)), resolveWithExt, function(err, results) {
      return async.filter(results, (function(item, cb) {
        return cb(item != null);
      }), function(results) {
        if (results.length > 1) {
          doneResolvingPath("ambiguous import: " + import_string);
          return;
        }
        return doneResolvingPath(null, results[0]);
      });
    });
  };

  cached_files = {};

  root = null;

  options = null;

  resolveDependencyChain = function(root, doneResolvingDependencyChain) {
    var deps, processNode, seen;
    deps = [];
    seen = {};
    processNode = function(node, doneProcessingNode) {
      return async.map(node.deps, resolvePath, function(err, resolved_deps) {
        var dep, dep_path, funcs, _i, _len;
        if (err) {
          doneResolvingDependencyChain(err);
          return;
        }
        funcs = [];
        for (_i = 0, _len = resolved_deps.length; _i < _len; _i++) {
          dep_path = resolved_deps[_i];
          dep = cached_files[dep_path];
          if (seen[dep.path] != null) {
            continue;
          }
          seen[dep.path] = true;
          funcs.push(async.apply(processNode, dep));
        }
        return async.parallel(funcs, function(err, results) {
          if (err) {
            doneResolvingDependencyChain(err);
            return;
          }
          deps.push(node);
          return doneProcessingNode();
        });
      });
    };
    return processNode(root, function() {
      return doneResolvingDependencyChain(null, deps);
    });
  };

  collectDependencies = function(import_string, doneCollectingDependencies) {
    return resolvePath(import_string, function(err, canonical_path) {
      var cached_file, callNext, parseAndHandleErr;
      if (err) {
        doneCollectingDependencies(err);
        return;
      }
      parseAndHandleErr = function(cb) {
        return parseFile(canonical_path, function(err, file) {
          if (err) {
            doneCollectingDependencies(err);
            return;
          }
          if (root == null) {
            root = file;
          }
          cached_files[file.path] = file;
          return cb(file);
        });
      };
      callNext = function(file) {
        return async.map(file.deps, collectDependencies, doneCollectingDependencies);
      };
      if ((cached_file = cached_files[canonical_path]) != null) {
        return fs.stat(canonical_path, function(err, stat) {
          if (cached_file.mtime === +stat.mtime) {
            if (root == null) {
              root = cached_file;
            }
            return callNext(cached_file);
          } else {
            return parseAndHandleErr(callNext);
          }
        });
      } else {
        return parseAndHandleErr(callNext);
      }
    });
  };

  compile = function(_options, cb) {
    options = _options;
    root = null;
    return collectDependencies(options.mainfile, function(err) {
      if (err) {
        cb(err);
        return;
      }
      return resolveDependencyChain(root, function(err, dependency_chain) {
        var dep, output;
        if (err) {
          cb(err);
          return;
        }
        output = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
            dep = dependency_chain[_i];
            _results.push(dep.compiled_js);
          }
          return _results;
        })()).join("\n");
        return cb(null, output);
      });
    });
  };

  compile.extensions = parsers = {
    '.coffee': {
      compile: function(code) {
        return require('coffee-script').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    },
    '.js': {
      compile: function(code) {
        if (options.bare) {
          return code;
        } else {
          return "(function(){\n" + code + "}).call(this);";
        }
      },
      import_re: /^\/\/import (".+");?$/gm
    },
    '.co': {
      compile: function(code) {
        return require('coco').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    },
    '.ls': {
      compile: function(code) {
        return require('LiveScript').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    }
  };

  module.exports = compile;

}).call(this);

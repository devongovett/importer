// Generated by CoffeeScript 1.3.3
(function() {
  var async, cached_files, collectDependencies, compile, fs, options, parseFile, parsers, path, resolveDependencyChain, resolvePath, root;

  fs = require('fs');

  path = require('path');

  async = require('async');

  parseFile = function(full_path, cb) {
    var file;
    file = {
      path: full_path,
      compiled_js: null,
      mtime: null,
      deps: []
    };
    return fs.stat(full_path, function(err, stat) {
      if (err) {
        cb(err);
        return;
      }
      file.mtime = +stat.mtime;
      return fs.readFile(full_path, 'utf8', function(err, source) {
        var funcs, import_string, parser, re, result;
        if (err) {
          cb(err);
          return;
        }
        parser = parsers[path.extname(full_path)];
        try {
          file.compiled_js = parser.compile(source);
        } catch (err) {
          cb(err);
          return;
        }
        re = parser.import_re;
        re.lastIndex = 0;
        funcs = [];
        while (result = re.exec(source)) {
          import_string = result[1].slice(1, -1);
          if (import_string[0] !== '/') {
            import_string = path.join(path.dirname(full_path), import_string);
            funcs.push(async.apply(resolvePath, import_string));
          }
        }
        return async.parallel(funcs, function(err, results) {
          if (err) {
            cb(err);
            return;
          }
          file.deps = results;
          return cb(null, file);
        });
      });
    });
  };

  resolvePath = function(import_string, doneResolvingPath) {
    var resolveWithExt;
    resolveWithExt = function(ext, cb) {
      return fs.realpath(path.resolve(import_string + ext), function(err, real_path) {
        if (err) {
          cb(null, null);
          return;
        }
        return fs.stat(real_path, function(err, stat) {
          if (err || stat.isDirectory()) {
            return cb(null, null);
          } else {
            return cb(null, real_path);
          }
        });
      });
    };
    return async.map([""].concat(Object.keys(parsers)), resolveWithExt, function(err, results) {
      return async.filter(results, (function(item, cb) {
        return cb(item != null);
      }), function(results) {
        if (results.length > 1) {
          doneResolvingPath("ambiguous import: " + import_string);
          return;
        }
        return doneResolvingPath(null, results[0]);
      });
    });
  };

  cached_files = {};

  root = null;

  options = null;

  resolveDependencyChain = function() {
    var deps, processNode, seen;
    deps = [];
    seen = {};
    processNode = function(node) {
      var dep, dep_path, _i, _len, _ref;
      _ref = node.deps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dep_path = _ref[_i];
        dep = cached_files[dep_path];
        if (seen[dep.path] != null) {
          continue;
        }
        seen[dep.path] = true;
        processNode(dep);
      }
      return deps.push(node);
    };
    processNode(root);
    return deps;
  };

  collectDependencies = function(import_string, doneCollectingDependencies) {
    return resolvePath(import_string, function(err, canonical_path) {
      var cached_file, callNext, parseAndHandleErr;
      if (err) {
        doneCollectingDependencies(err);
        return;
      }
      parseAndHandleErr = function(cb) {
        return parseFile(canonical_path, function(err, file) {
          if (err) {
            doneCollectingDependencies(err);
            return;
          }
          if (root == null) {
            root = file;
          }
          cached_files[file.path] = file;
          return cb(file);
        });
      };
      callNext = function(file) {
        return async.map(file.deps, collectDependencies, doneCollectingDependencies);
      };
      if ((cached_file = cached_files[canonical_path]) != null) {
        return fs.stat(canonical_path, function(err, stat) {
          if (cached_file.mtime === +stat.mtime) {
            return callNext(cached_file);
          } else {
            return parseAndHandleErr(callNext);
          }
        });
      } else {
        return parseAndHandleErr(callNext);
      }
    });
  };

  compile = function(_options, cb) {
    options = _options;
    return collectDependencies(options.mainfile, function(err) {
      var dep, dependency_chain, output;
      if (err) {
        cb(err);
        return;
      }
      dependency_chain = resolveDependencyChain(root);
      output = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
          dep = dependency_chain[_i];
          _results.push(dep.compiled_js);
        }
        return _results;
      })()).join("\n");
      return cb(null, output);
    });
  };

  compile.extensions = parsers = {
    '.coffee': {
      compile: function(code) {
        return require('coffee-script').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    },
    '.js': {
      compile: function(code) {
        if (options.bare) {
          return code;
        } else {
          return "(function(){\n" + code + "}).call(this);";
        }
      },
      import_re: /^\/\/import (".+");?$/gm
    },
    '.co': {
      compile: function(code) {
        return require('coco').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    },
    '.ls': {
      compile: function(code) {
        return require('LiveScript').compile(code, {
          bare: options.bare
        });
      },
      import_re: /^#import (".+")$/gm
    }
  };

  module.exports = compile;

}).call(this);

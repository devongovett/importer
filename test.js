// Generated by CoffeeScript 1.3.3
(function() {
  var async, exec, fail_count, fs, msg, pass_count, path, temp, tests_dir, tmp_js_file;

  exec = require("child_process").exec;

  fs = require("fs");

  path = require("path");

  async = require("async");

  temp = require("temp");

  tests_dir = "./tests/";

  tmp_js_file = "./.test_out.tmp.js";

  msg = "";

  pass_count = 0;

  fail_count = 0;

  fs.readdir(tests_dir, function(err, files) {
    var doTest;
    doTest = function(test_dir, testDone) {
      var expect_file, main_file, switches_file;
      main_file = path.join(tests_dir, test_dir, "test");
      expect_file = path.join(tests_dir, test_dir, "expected.txt");
      switches_file = path.join(tests_dir, test_dir, "switches.txt");
      return (function(exec_result, expected_output) {
        var execTest, readExpected;
        execTest = function(cb) {
          return fs.readFile(switches_file, 'utf8', function(err, switches) {
            switches = (switches || "").replace(/\n/g, " ");
            return temp.open("", function(err, tmp_js_file) {
              var cmdline;
              cmdline = "node ./cmd.js " + switches + " " + main_file + " " + tmp_js_file.path;
              return exec(cmdline, function(err, stdout, stderr) {
                if (stderr.length > 0) {
                  exec_result = {
                    compile: false,
                    msg: stderr
                  };
                  cb();
                }
                return exec("node " + tmp_js_file.path, function(err, stdout, stderr) {
                  fs.close(tmp_js_file.fd, function() {
                    return fs.unlink(tmp_js_file.path);
                  });
                  if (stderr.length > 0) {
                    exec_result = {
                      compile: true,
                      run: false,
                      msg: stderr
                    };
                  } else {
                    exec_result = {
                      compile: true,
                      run: true,
                      output: stdout
                    };
                  }
                  return cb();
                });
              });
            });
          });
        };
        readExpected = function(cb) {
          return fs.readFile(expect_file, 'utf8', function(err, out) {
            expected_output = out;
            return cb();
          });
        };
        return async.parallel([execTest, readExpected], function() {
          if (exec_result.compile) {
            if (exec_result.run) {
              if (exec_result.output === expected_output) {
                process.stdout.write(".");
                pass_count += 1;
              } else {
                process.stdout.write("F");
                fail_count += 1;
                msg += "\n\n======== " + test_dir + " failed =========\n-------- Expected Output:   ---------\n" + expected_output + "\n-------------------------------------\n-------- Actual Output:     ---------\n" + exec_result.output + "\n-------------------------------------";
              }
            } else {
              process.stdout.write("E");
              fail_count += 1;
              msg += "\n\n======== " + test_dir + " crashed ========\n-------- stderr:            ---------\n" + exec_result.msg + "\n-------------------------------------";
            }
          } else {
            process.stdout.write("X");
            fail_count += 1;
            msg += "\n\n======== " + test_dir + " compile error ==\n-------- stderr:            ---------\n" + exec_result.msg + "\n-------------------------------------";
          }
          return testDone();
        });
      })(null, null);
    };
    return async.map(files, doTest, function() {
      if (msg.length > 0) {
        process.stdout.write(msg);
      }
      process.stdout.write("\n" + pass_count + " passed, " + fail_count + " failed.\n");
      fs.unlink(tmp_js_file);
      if (fail_count > 0) {
        return process.exit(1);
      }
    });
  });

}).call(this);
